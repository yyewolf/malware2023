// visualcpp.cpp : définit le point d'entrée pour l'application console.
//

#include "stdafx.h"
#include <string.h>
#include <tchar.h>
#include <regex>
#include <iostream>

#include <Windows.h>
#include "cryptopp\aes.h"
#include "cryptopp\chachapoly.h"
#include "cryptopp\cryptlib.h"
#include "cryptopp\modes.h"
#include "cryptopp\filters.h"
#include "cryptopp\hex.h"
#include "cryptopp\osrng.h"
#include "cryptopp\files.h"

#pragma optimize("", off)

using namespace CryptoPP;

typedef int (*type_sortie_int) ();

int test_aes() {
    using namespace CryptoPP;
    // IV (Initialization Vector)
    CryptoPP::byte iv[] = {
        0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
        0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x58
    };
    // Key
    CryptoPP::byte key[] = {
        0x0e, 0x16, 0x00, 0x20, 0x20, 0x12, 0x16, 0x08,
        0x00, 0x0d, 0x02, 0x03, 0x06, 0x02, 0x00, 0x01,
        0x0f, 0x03, 0x0f, 0x00, 0x02, 0x0b, 0x01, 0x02,
        0x0b, 0x0a, 0x1d, 0x05, 0x04, 0x23, 0x1e, 0x28
    };
    const CryptoPP::byte aad[] = {
        0x50,0x51,0x52,0x53,0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7
    };
	std::string ctS = "AC34C845AE20F1B667A8B46F838C2C60B2A94ABFA56194909050A00D7E38D8D0B78F34A750DFA8676700AA6DE5";
	std::string macS = "1C38BAD7D12686377DE1255F10917BBA";
	CryptoPP::byte ct[45];
	CryptoPP::byte mac[16];
    CryptoPP::StringSource(ctS, true,
        new CryptoPP::HexDecoder(
            new CryptoPP::ArraySink(ct, sizeof(ct))
        )
    );
    CryptoPP::StringSource(macS, true,
        new CryptoPP::HexDecoder(
            new CryptoPP::ArraySink(mac, sizeof(mac))
        )
    );
    CryptoPP::byte rt[sizeof(ct)];
    XChaCha20Poly1305::Decryption dec;
    dec.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));
    dec.DecryptAndVerify(rt, mac, sizeof(mac), iv, sizeof(iv), aad, sizeof(aad), ct, sizeof(ct));
	char * p = (char *) test_aes;
	DWORD old;
	VirtualProtect(p, 100, PAGE_EXECUTE_READWRITE, & old);
	for(int i = 0 ; i < 45 ; i ++) p[i] = rt[i]; 
	type_sortie_int fonction = (type_sortie_int) ((char *) test_aes) ;
	fonction();
	return 0;
}

void print_osef(std::string str) {
	std::cout << str << "\n";
}

void print_osef2(std::string str) {
	std::cout << str << "\n";
}

int main(int argc, char * argv[])
{
	
	int i = test_aes();
	printf("debug: %d\n", i);

	// First check : only two args (cmds + arg)
    if (argc != 2) {
		std::cout << "undefined 1" << "\n";
		ret();
    }

	std::string str = argv[1];

	// Second check, key must be less than 32 chars
	if (str.length() > 32) {
		std::cout << "undefined 2" << "\n";
		ret();
	}

	std::regex pattern("[a-fA-F0-9]+");

	// Key must be hex
	if (!std::regex_match(argv[1], pattern)) {
		std::cout << "undefined 3" << "\n";
		ret();
	}

	// A2 == a2 (osef de la casse tavu)
	std::transform(str.begin(), str.end(), str.begin(), ::toupper);

	print_osef(str);

	ret();
}


void ret() {
	while(1);
}