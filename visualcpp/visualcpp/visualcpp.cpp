// visualcpp.cpp : définit le point d'entrée pour l'application console.
//

#include "stdafx.h"
#include <string.h>
#include <tchar.h>
#include <regex>
#include <iostream>

#include <Windows.h>
#include "cryptopp\aes.h"
#include "cryptopp\modes.h"
#include "cryptopp\filters.h"
#include "cryptopp\osrng.h"

using namespace CryptoPP;

void test_aes() {
	// Ciphertext
    CryptoPP::byte ciphertext[] = {
        0xf3, 0x56, 0x57, 0x5f, 0x18, 0xe0, 0xe7, 0x75,
        0xdd, 0x8b, 0x80, 0x91, 0x7a, 0x8f, 0xae, 0xef,
        0x1a, 0x01, 0x49, 0x9a, 0x0e, 0xdf, 0x78, 0xa2
    };

    // IV (Initialization Vector)
    CryptoPP::byte iv[] = {
        0x05, 0x20, 0x65, 0x82, 0x06, 0x54, 0x02, 0x20,
        0x01, 0x03, 0x15, 0x45, 0x84, 0x56, 0x58, 0x9
    };

    // Key
    CryptoPP::byte key[] = {
        0x0e, 0x16, 0x00, 0x20, 0x20, 0x12, 0x16, 0x08,
        0x00, 0x0d, 0x02, 0x03, 0x06, 0x02, 0x00, 0x01,
        0x0f, 0x03, 0x0f, 0x00, 0x02, 0x0b, 0x01, 0x02,
        0x0b, 0x0a, 0x1d, 0x05, 0x04, 0x23, 0x1e, 0x28
    };
    CryptoPP::byte recoveredtext[24];

    // AES decryption
    CFB_Mode<AES>::Decryption cfbDecryption(key, sizeof(key), iv);

    StringSource(ciphertext, sizeof(ciphertext), true,
                 new StreamTransformationFilter(cfbDecryption,
                                                new ArraySink(recoveredtext, sizeof(recoveredtext))));

	void (*x86_func)(void) = (void (*)(void))((unsigned char *) recoveredtext);
	std::cout << "test" << "\n";
	char * ppeb;
	
	char * p = (char *) test_aes;
	DWORD old;
	VirtualProtect(p, 10, PAGE_EXECUTE_READWRITE, & old);
	x86_func();
	printf("debug ? %d\n", ppeb[2]);
	printf("dbg ? %d\n", ppeb[104] & 0x70);
}

void print_osef(std::string str) {
	std::cout << str << "\n";
}

void print_osef2(std::string str) {
	std::cout << str << "\n";
}

int main(int argc, char * argv[])
{
	
	test_aes();

	// First check : only two args (cmds + arg)
    if (argc != 2) {
		std::cout << "undefined 1" << "\n";
        return 1;
    }

	std::string str = argv[1];

	// Second check, key must be less than 32 chars
	if (str.length() > 32) {
		std::cout << "undefined 2" << "\n";
		return 2;
	}

	std::regex pattern("[a-fA-F0-9]+");

	// Key must be hex
	if (!std::regex_match(argv[1], pattern)) {
		std::cout << "undefined 3" << "\n";
		return 3;
	}

	// A2 == a2 (osef de la casse tavu)
	std::transform(str.begin(), str.end(), str.begin(), ::toupper);

	print_osef(str);

	return 0;
}
